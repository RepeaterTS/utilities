function isObject(e){return!("object"!=typeof e||!e)&&e.constructor===Object}const e=["string","bigint","number","boolean"];function isPrimitive(t){return e.includes(typeof t)}function deepClone(e){if(null===e||isPrimitive(e))return e;if(Array.isArray(e)){const t=[];for(const r of e)t.push(deepClone(r));return t}if(isObject(e)){const t={};for(const[r,n]of Object.entries(e))t[r]=deepClone(n);return t}if(e instanceof Map){const t=new e.constructor;for(const[r,n]of e.entries())t.set(r,deepClone(n));return t}if(e instanceof Set){const t=new e.constructor;for(const r of e.values())t.add(deepClone(r));return t}return e}function mergeDefault(e,t){if(!t)return deepClone(e);for(const[r,n]of Object.entries(e)){const e=Reflect.get(t,r);void 0===e?Reflect.set(t,r,deepClone(n)):isObject(e)&&Reflect.set(t,r,mergeDefault(null!=n?n:{},e))}return t}function chunk(e,t){if(!Array.isArray(e))throw new TypeError("entries must be an array.");if(!Number.isInteger(t))throw new TypeError("chunkSize must be an integer.");if(t<1)throw new RangeError("chunkSize must be 1 or greater.");const r=e.slice(),n=[];for(;r.length;)n.push(r.splice(0,t));return n}export{chunk,deepClone,isObject,isPrimitive,mergeDefault};
//# sourceMappingURL=index.mjs.map
