{"version":3,"file":"index.mjs","sources":["../src/library/isObject.ts","../src/library/isPrimitive.ts","../src/library/deepClone.ts","../src/library/mergeDefault.ts","../src/library/chunk.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/ban-types */\n/**\n * Verify if the input is an object literal (or class).\n * @param input The object to verify\n */\nexport function isObject(\n  input: unknown\n): input is Record<PropertyKey, unknown> | object {\n  return typeof input === \"object\" && input\n    ? input.constructor === Object\n    : false;\n}\n","const primitiveTypes = [\"string\", \"bigint\", \"number\", \"boolean\"];\n\n/**\n * Check whether a value is a primitive\n * @param input The input to check\n */\nexport function isPrimitive(\n  input: unknown\n): input is string | bigint | number | boolean {\n  return primitiveTypes.includes(typeof input);\n}\n","import { isObject } from \"./isObject\";\nimport { isPrimitive } from \"./isPrimitive\";\n\n/**\n * Deep clone an object\n * @param source The object to clone\n */\nexport function deepClone<T>(source: T): T {\n  // Check if it's a primitive (with exception of function and null, which is typeof object)\n  if (source === null || isPrimitive(source)) return source;\n  if (Array.isArray(source)) {\n    const output = ([] as unknown) as T & T extends (infer S)[] ? S[] : never;\n    for (const value of source) output.push(deepClone(value));\n    return (output as unknown) as T;\n  }\n  if (isObject(source)) {\n    const output = {} as Record<PropertyKey, unknown>;\n    for (const [key, value] of Object.entries(source))\n      output[key] = deepClone(value);\n    return (output as unknown) as T;\n  }\n  if (source instanceof Map) {\n    const output = (new (source.constructor as MapConstructor)() as unknown) as T &\n      T extends Map<infer K, infer V>\n      ? Map<K, V>\n      : never;\n    for (const [key, value] of source.entries())\n      output.set(key, deepClone(value));\n    return (output as unknown) as T;\n  }\n  if (source instanceof Set) {\n    const output = (new (source.constructor as SetConstructor)() as unknown) as T &\n      T extends Set<infer K>\n      ? Set<K>\n      : never;\n    for (const value of source.values()) output.add(deepClone(value));\n    return (output as unknown) as T;\n  }\n  return source;\n}\n","import { deepClone } from \"./deepClone\";\nimport { isObject } from \"./isObject\";\nimport type { DeepRequired } from \"./utilityTypes\";\n\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions, @typescript-eslint/ban-types\ntype NonNullObject = {};\n\n/**\n * Deep merges 2 objects. Properties from the second parameter are applied to the first.\n * @remark `overwrites` is also mutated!\n * @remark If the value of a key in `overwrites` is `undefined` then the value of that same key in `base` is used instead!\n * @remark This is essentially `{ ...base, ...overwrites }` but recursively\n * @param base Base object\n * @param overwrites Overwrites to apply\n * @example\n * ```ts\n * const base = { a: 0, b: 1 };\n * const overwrites = {}; // will be { a: 0, b: 1 } after merge\n * mergeDefault(base, overwrites) // { a: 0, b: 1 }\n * ```\n * @example\n * ```ts\n * const base = { a: 0, b: 1 };\n * const overwrites = { a: 2, i: 3 };\n * mergeDefault(base, overwrites) // { a: 2, i: 3, b: 1 };\n * ```\n * @example\n * ```ts\n * const base = { a: 0, b: 1 };\n * const overwrites = { a: null };\n * mergeDefault(base, overwrites) // { a: null, b: 1 };\n * ```\n * @example\n * ```ts\n * const base = { a: 0, b: 1 };\n * const overwrites = { a: undefined };\n * mergeDefault(base, overwrites) // { a: 0, b: 1 };\n * ```\n * @example\n * ```ts\n * const base = { a: null };\n * const overwrites = { a: { b: 5 } };\n * mergeDefault(base, overwrites) // { a: { b: 5 } };\n * ```\n */\nexport function mergeDefault<A extends NonNullObject, B extends Partial<A>>(\n  base: A,\n  overwrites?: B\n): DeepRequired<A & B> {\n  // If no overwrites are specified then deep clone the base\n  if (!overwrites) return deepClone(base) as DeepRequired<A & B>;\n\n  for (const [baseKey, baseValue] of Object.entries(base)) {\n    const overwritesValueAtBaseKey = Reflect.get(overwrites, baseKey);\n\n    if (typeof overwritesValueAtBaseKey === \"undefined\") {\n      Reflect.set(overwrites, baseKey, deepClone(baseValue));\n    } else if (isObject(overwritesValueAtBaseKey)) {\n      Reflect.set(\n        overwrites,\n        baseKey,\n        mergeDefault(\n          (baseValue ?? {}) as NonNullObject,\n          overwritesValueAtBaseKey\n        )\n      );\n    }\n  }\n\n  return overwrites as DeepRequired<A & B>;\n}\n","/**\n * Splits up an array into chunks\n * @param array The array to chunk up\n * @param chunkSize The size of each individual chunk\n */\nexport function chunk<T>(array: readonly T[], chunkSize: number): T[][] {\n  if (!Array.isArray(array)) throw new TypeError(\"entries must be an array.\");\n  if (!Number.isInteger(chunkSize))\n    throw new TypeError(\"chunkSize must be an integer.\");\n  if (chunkSize < 1) throw new RangeError(\"chunkSize must be 1 or greater.\");\n  const clone: T[] = array.slice();\n  const chunks: T[][] = [];\n  while (clone.length) chunks.push(clone.splice(0, chunkSize));\n  return chunks;\n}\n"],"names":["isObject","input","constructor","Object","primitiveTypes","isPrimitive","includes","deepClone","source","Array","isArray","output","value","push","key","entries","Map","set","Set","values","add","mergeDefault","base","overwrites","baseKey","baseValue","overwritesValueAtBaseKey","Reflect","get","chunk","array","chunkSize","TypeError","Number","isInteger","RangeError","clone","slice","chunks","length","splice"],"mappings":"SAKgBA,SACdC,GAEA,QAAwB,iBAAVA,IAAsBA,IAChCA,EAAMC,cAAgBC,OCT5B,MAAMC,EAAiB,CAAC,SAAU,SAAU,SAAU,oBAMtCC,YACdJ,GAEA,OAAOG,EAAeE,gBAAgBL,YCFxBM,UAAaC,GAE3B,GAAe,OAAXA,GAAmBH,YAAYG,GAAS,OAAOA,EACnD,GAAIC,MAAMC,QAAQF,GAAS,CACzB,MAAMG,EAAU,GAChB,IAAK,MAAMC,KAASJ,EAAQG,EAAOE,KAAKN,UAAUK,IAClD,OAAQD,EAEV,GAAIX,SAASQ,GAAS,CACpB,MAAMG,EAAS,GACf,IAAK,MAAOG,EAAKF,KAAUT,OAAOY,QAAQP,GACxCG,EAAOG,GAAOP,UAAUK,GAC1B,OAAQD,EAEV,GAAIH,aAAkBQ,IAAK,CACzB,MAAML,EAAU,IAAKH,EAAON,YAI5B,IAAK,MAAOY,EAAKF,KAAUJ,EAAOO,UAChCJ,EAAOM,IAAIH,EAAKP,UAAUK,IAC5B,OAAQD,EAEV,GAAIH,aAAkBU,IAAK,CACzB,MAAMP,EAAU,IAAKH,EAAON,YAI5B,IAAK,MAAMU,KAASJ,EAAOW,SAAUR,EAAOS,IAAIb,UAAUK,IAC1D,OAAQD,EAEV,OAAOH,WCOOa,aACdC,EACAC,GAGA,IAAKA,EAAY,OAAOhB,UAAUe,GAElC,IAAK,MAAOE,EAASC,KAActB,OAAOY,QAAQO,GAAO,CACvD,MAAMI,EAA2BC,QAAQC,IAAIL,EAAYC,QAEjB,IAA7BE,EACTC,QAAQV,IAAIM,EAAYC,EAASjB,UAAUkB,IAClCzB,SAAS0B,IAClBC,QAAQV,IACNM,EACAC,EACAH,aACGI,MAAAA,EAAAA,EAAa,GACdC,IAMR,OAAOH,WChEOM,MAASC,EAAqBC,GAC5C,IAAKtB,MAAMC,QAAQoB,GAAQ,MAAM,IAAIE,UAAU,6BAC/C,IAAKC,OAAOC,UAAUH,GACpB,MAAM,IAAIC,UAAU,iCACtB,GAAID,EAAY,EAAG,MAAM,IAAII,WAAW,mCACxC,MAAMC,EAAaN,EAAMO,QACnBC,EAAgB,GACtB,KAAOF,EAAMG,QAAQD,EAAOzB,KAAKuB,EAAMI,OAAO,EAAGT,IACjD,OAAOO"}